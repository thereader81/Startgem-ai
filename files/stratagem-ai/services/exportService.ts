const stripMarkdown = (input: string) => {
  return input
    .replace(/```[\s\S]*?```/g, '')
    .replace(/`([^`]+)`/g, '$1')
    .replace(/^\s*[-*+]\s+/gm, '')
    .replace(/^\s*>\s?/gm, '')
    .replace(/^\s*#{1,6}\s+/gm, '')
    .replace(/\*\*(.*?)\*\*/g, '$1')
    .replace(/_/g, '')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
};

const slugify = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)+/g, '');

interface Section {
  title: string;
  body: string[];
}

const parseSections = (markdown: string): Section[] => {
  const lines = markdown.split('\n');
  const sections: Section[] = [];
  let current: Section = { title: 'Overview', body: [] };

  for (const line of lines) {
    if (line.startsWith('# ')) {
      if (current.body.length || current.title) sections.push(current);
      current = { title: line.replace('# ', '').trim(), body: [] };
      continue;
    }
    if (line.startsWith('## ')) {
      if (current.body.length || current.title) sections.push(current);
      current = { title: line.replace('## ', '').trim(), body: [] };
      continue;
    }
    if (line.trim()) {
      current.body.push(line.trim());
    }
  }

  if (current.body.length || current.title) sections.push(current);
  return sections.filter((section) => section.title || section.body.length);
};

const toBullets = (lines: string[]) =>
  lines
    .map((line) => line.replace(/^[-*+]\s+/, '').replace(/^•\s+/, '').trim())
    .filter(Boolean)
    .slice(0, 8);

export const exportToPdf = async (title: string, markdown: string) => {
  const { jsPDF } = await import('jspdf');
  const doc = new jsPDF({ unit: 'pt', format: 'a4' });
  const margin = 48;
  const width = doc.internal.pageSize.getWidth() - margin * 2;
  const body = stripMarkdown(markdown);

  doc.setFont('helvetica', 'bold');
  doc.setFontSize(18);
  doc.text(title, margin, margin);

  doc.setFont('helvetica', 'normal');
  doc.setFontSize(11);

  const lines = doc.splitTextToSize(body, width);
  let cursorY = margin + 28;
  const lineHeight = 14;

  lines.forEach((line: string) => {
    if (cursorY > doc.internal.pageSize.getHeight() - margin) {
      doc.addPage();
      cursorY = margin;
    }
    doc.text(line, margin, cursorY);
    cursorY += lineHeight;
  });

  doc.save(`${slugify(title)}.pdf`);
};

export const exportToPptx = async (title: string, markdown: string) => {
  const { default: PptxGenJS } = await import('pptxgenjs');
  const pptx = new PptxGenJS();
  pptx.layout = 'LAYOUT_WIDE';
  pptx.author = 'Stratagem AI Pro';

  const sections = parseSections(markdown);
  const slideTitle = pptx.addSlide();
  slideTitle.addText(title, {
    x: 0.6,
    y: 1.4,
    w: 12.2,
    h: 1,
    fontSize: 30,
    bold: true,
    fontFace: 'Calibri',
    color: '1C1917'
  });
  slideTitle.addText('Generated by Stratagem AI Pro', {
    x: 0.6,
    y: 2.6,
    w: 12.2,
    h: 0.5,
    fontSize: 14,
    fontFace: 'Calibri',
    color: '78716C'
  });

  sections.slice(0, 8).forEach((section) => {
    const slide = pptx.addSlide();
    slide.addText(section.title || 'Section', {
      x: 0.6,
      y: 0.4,
      w: 12,
      h: 0.6,
      fontSize: 24,
      bold: true,
      fontFace: 'Calibri',
      color: '1C1917'
    });

    const bullets = toBullets(section.body);
    const bulletLines = bullets.length ? bullets : ['See detailed appendix in markdown export.'];
    const bulletText = bulletLines.map((line) => `• ${line}`).join('\n');

    slide.addText(bulletText, {
      x: 0.8,
      y: 1.3,
      w: 11.6,
      h: 5.2,
      fontSize: 15,
      fontFace: 'Calibri',
      color: '44403C',
      valign: 'top'
    });
  });

  await pptx.writeFile({ fileName: `${slugify(title)}.pptx` });
};

export const exportToDocx = async (title: string, markdown: string) => {
  const { Document, Packer, Paragraph, TextRun, HeadingLevel } = await import('docx');
  const sections = parseSections(markdown);

  const children = [
    new Paragraph({
      text: title,
      heading: HeadingLevel.TITLE
    })
  ];

  sections.forEach((section) => {
    if (section.title) {
      children.push(
        new Paragraph({
          text: section.title,
          heading: HeadingLevel.HEADING_1
        })
      );
    }

    const bullets = toBullets(section.body);
    if (bullets.length) {
      bullets.forEach((bullet) => {
        children.push(
          new Paragraph({
            text: bullet,
            bullet: {
              level: 0
            }
          })
        );
      });
    } else if (section.body.length) {
      children.push(
        new Paragraph({
          children: [new TextRun(section.body.join(' '))]
        })
      );
    }
  });

  const doc = new Document({
    sections: [
      {
        properties: {},
        children
      }
    ]
  });

  const blob = await Packer.toBlob(doc);
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `${slugify(title)}.docx`;
  link.click();
  URL.revokeObjectURL(link.href);
};
